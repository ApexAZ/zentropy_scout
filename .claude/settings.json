{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'SECURITY GATE: Spawn the security-triage subagent (model: opus) IMMEDIATELY. Do NOT query scanners yourself — the subagent handles everything autonomously. After it reports back: (1) CLEAR — proceed to implementation. (2) VULNERABLE — fix immediately, no other work until resolved. (3) FALSE POSITIVE — you MUST act as a zero-trust prosecutor. Challenge every FALSE POSITIVE verdict. Read the actual code the subagent cites. Look for gaps in its defense chain. Assume the subagent is wrong until you independently verify the evidence. Only dismiss via gh api if YOUR independent review confirms the finding is unexploitable. (4) NEEDS INVESTIGATION — escalate to user via AskUserQuestion. Do NOT proceed to implementation until ALL findings are resolved. This is non-negotiable.'"
          }
        ]
      },
      {
        "matcher": "compact",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'SECURITY GATE (post-compact): Spawn the security-triage subagent (model: opus) IMMEDIATELY. Do NOT query scanners yourself — the subagent handles everything autonomously. After it reports back: (1) CLEAR — proceed to implementation. (2) VULNERABLE — fix immediately, no other work until resolved. (3) FALSE POSITIVE — you MUST act as a zero-trust prosecutor. Challenge every FALSE POSITIVE verdict. Read the actual code the subagent cites. Look for gaps in its defense chain. Assume the subagent is wrong until you independently verify the evidence. Only dismiss via gh api if YOUR independent review confirms the finding is unexploitable. (4) NEEDS INVESTIGATION — escalate to user via AskUserQuestion. Do NOT proceed to implementation until ALL findings are resolved. This is non-negotiable.'"
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "bash -c 'FILE=\"$1\"; if [[ \"$FILE\" == *docs/requirements/* ]]; then echo \"BLOCKED: Cannot modify requirement documents. They are read-only specifications.\" >&2; exit 1; fi' -- "
          }
        ]
      },
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "bash -c 'FILE=\"$1\"; if [[ \"$FILE\" == *zap-rules.tsv* ]]; then echo \"BLOCKED: zap-rules.tsv must remain empty. IGNORE rules suppress alerts before SARIF upload, preventing human review. Dismiss false positives individually via gh api — see security-triage subagent instructions.\" >&2; exit 1; fi' -- "
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "bash -c 'if [[ \"$CLAUDE_TOOL_INPUT\" == *\"git commit\"* ]]; then echo \"WORKFLOW CHECK: Before committing, verify: (1) code-reviewer (2) security-reviewer (3) qa-reviewer (4) All findings resolved — See zentropy-planner steps 4-6. If this is a phase gate fix or plan-only commit, proceed.\" >&2; fi'"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "bash -c 'FILE=\"$1\"; if [[ \"$FILE\" == *.py ]]; then cd backend 2>/dev/null && ruff check --fix \"$FILE\" 2>/dev/null && ruff format \"$FILE\" 2>/dev/null || true; fi' -- "
          }
        ]
      }
    ]
  },
  "permissions": {
    "allow": [
      "Read",
      "Grep",
      "Glob",
      "LS"
    ],
    "deny": []
  }
}
